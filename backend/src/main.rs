// klyja/backend/src/main.rs
use axum::{
    //    body::Body,
    // extract::{Request, State}, //Path, State},
    http::StatusCode, //HeaderMap, HeaderValue, Method},
    //    response::IntoResponse,
    routing::{get, post},
    Extension,
    Router,
    //ServiceExt,
};
//use bytes::Bytes; // Receiving raw request body
use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenvy::dotenv;
//use prost::Message;
use std::env;
use std::net::SocketAddr;
use std::path::PathBuf;
//use tower::ServiceBuilder;
use tower_http::{
    cors::{Any, CorsLayer},
    services::ServeDir,
    trace::TraceLayer,
};

// Include Generated Protobuf Code
mod protobuf_gen {
    include!(concat!(env!("OUT_DIR"), "/klyja.map_animation.v1.rs"));
}

//use protobuf_gen::MapAnimation;
// End protobuf inclusion

// Define the embedded migrations constant
// Assumes migrations directory is at ../migrations relative to backend/Cargo.toml
pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("../migrations");

// Define a type alias for the connection pool
pub type DbPool = r2d2::Pool<ConnectionManager<PgConnection>>;

// Define placeholder modules (we'll create them later if needed)
mod db; //placeholder can contain db helper functions later
mod handlers;
mod models;
mod schema; // Will be generated by diesel print-schema

#[tokio::main]
async fn main() {
    dotenv().ok(); // Load .env file

    // Setup logging
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    // --- Database Setup ---
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create database connection pool.");

    // Run embedded migrations on startup
    {
        // Scope to release connection quickly
        tracing::info!("Attempting to run database migrations...");
        let mut conn = pool
            .get()
            .expect("Failed to get DB connection for migrations");
        match conn.run_pending_migrations(MIGRATIONS) {
            Ok(_) => tracing::info!("Database migrations executed successfully."),
            Err(e) => tracing::error!("Failed to run database migrations: {}", e),
        }
    }
    // --- End Database Setup ---

    // --- Calculate Paths Agnostically ---
    // Get the directory containing backend/Cargo.toml at compile time
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // Get the workspace root (parent of the manifest dir)
    let project_root = manifest_dir
        .parent()
        .expect("Failed to get project root directory");

    // Construct absolute paths to static asset directories
    let frontend_path = project_root.join("frontend");
    let wasm_pkg_path = project_root.join("geco/pkg");

    tracing::info!(
        "Serving frontend static files from: {}",
        frontend_path.display()
    );
    tracing::info!(
        "Serving WASM package files from: {}",
        wasm_pkg_path.display()
    );
    // --- End Path Calculation ---

    // --- Routing Setup ---
    // API routes (add more later in handlers.rs)
    let api_routes = Router::new()
        .route("/health", get(|| async { (StatusCode::OK, "Healthy!") }))
        .route("/save_animation", post(handlers::save_animation_handler)) // Example for later
        .route("/load_animation/:id", get(handlers::load_animation_handler)); // Example for later

    // Service to serve WASM package files from `../geco/pkg`
    let wasm_pkg_service = ServeDir::new(wasm_pkg_path).append_index_html_on_directories(false); // Don't serve index.html from here

    // Service to serve static frontend files from `../frontend`
    let static_files_service = ServeDir::new(frontend_path).append_index_html_on_directories(true); // Serve index.html for directories like "/"

    let app = Router::new()
        .nest("/api", api_routes) // API routes under /api
        .nest_service("/pkg", wasm_pkg_service) // WASM files under /pkg
        .fallback_service(static_files_service) // Serve frontend static files as fallback
        //.layer(Extension(pool)) // Add database pool state
        .with_state(pool.clone())
        //.layer(Extension(pool))
        .layer(TraceLayer::new_for_http()) // Add HTTP request logging
        .layer(
            // Add CORS layer - Allow requests from any origin (adjust for production)
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any) // Allows common methods
                .allow_headers(Any), // Allows common headers
        );
    // --- End Routing Setup ---

    // --- Server Startup ---
    let port_str = env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let port = port_str
        .parse::<u16>()
        .expect("PORT must be a valid u16 number");
    let addr = SocketAddr::from(([0, 0, 0, 0], port)); // Listen on all interfaces

    tracing::debug!("Server listening on http://{}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    // Use ServiceExt::<Request>::into_make_service()
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}
