// klyja/backend/src/main.rs
use axum::{
    http::StatusCode,
    routing::{get, post},
    Router,
};
use diesel::prelude::*;
use diesel::r2d2::{self, ConnectionManager};
use diesel_migrations::{embed_migrations, EmbeddedMigrations, MigrationHarness};
use dotenvy::dotenv;
use std::env;
use std::net::SocketAddr;
use std::path::PathBuf;
use tower_http::{
    cors::{Any, CorsLayer},
    services::ServeDir,
    trace::TraceLayer,
};

use utoipa::OpenApi;
use utoipa_swagger_ui::SwaggerUi;

// Include Generated Protobuf Code
mod protobuf_gen {
    include!(concat!(env!("OUT_DIR"), "/klyja.map_animation.v1.rs"));
}

mod db;
mod handlers;
mod models;
mod schema; // Will be generated by diesel print-schema
mod services;

// --- Define the ApiDoc struct ---
#[derive(OpenApi)]
#[openapi(
    paths(
        handlers::health_check_handler, // Add the health check handler
        handlers::save_animation_handler,
        handlers::load_animation_handler
    ),
    components(
        schemas(models::Animation) // List your ToSchema-derived models here
        // Add other schemas if you have them, e.g., error response schemas
        // schemas(ErrorResponse, AnotherModel)
    ),
    tags(
        (name = "Klyja Animations API", description = "API endpoints for managing map animations")
        // You can define tags referenced in handlers here, or utoipa will create them.
        // (name = "Animations", description = "Animation data operations"),
        // (name = "System", description = "System health checks")
    ),
    info(
        title = "Klyja Spherical Map Animation API",
        version = "v0.1.0",
        description = "This API serves the Klyja application, allowing users to save and load spherical map animation data.",
        contact(
            name = "Klyja Dev Team",
            url = "http://example.com/contact",
            email = "dev@example.com"
        ),
        license(
            name = "MIT OR Apache-2.0",
            url = "http://example.com/license"
        )
    )
)]
struct ApiDoc;

// Define the embedded migrations constant
// Assumes migrations directory is at ../migrations relative to backend/Cargo.toml
pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("../migrations");
// Define a type alias for the connection pool
pub type DbPool = r2d2::Pool<ConnectionManager<PgConnection>>;

#[tokio::main]
async fn main() {
    dotenv().ok(); // Load .env file

    // Setup logging
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    // --- Database Setup ---
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    let pool = r2d2::Pool::builder()
        .build(manager)
        .expect("Failed to create database connection pool.");

    // Run embedded migrations on startup
    {
        // Scope to release connection quickly
        tracing::info!("Attempting to run database migrations...");
        let mut conn = pool
            .get()
            .expect("Failed to get DB connection for migrations");
        match conn.run_pending_migrations(MIGRATIONS) {
            Ok(_) => tracing::info!("Database migrations executed successfully."),
            Err(e) => tracing::error!("Failed to run database migrations: {}", e),
        }
    }
    // --- End Database Setup ---

    // --- Calculate Paths Agnostically ---
    // Get the directory containing backend/Cargo.toml at compile time
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    // Get the workspace root (parent of the manifest dir)
    let project_root = manifest_dir
        .parent()
        .expect("Failed to get project root directory");

    // Construct absolute paths to static asset directories
    let frontend_path = project_root.join("frontend");
    let wasm_pkg_path = project_root.join("geco/pkg");

    tracing::info!(
        "Serving frontend static files from: {}",
        frontend_path.display()
    );
    tracing::info!(
        "Serving WASM package files from: {}",
        wasm_pkg_path.display()
    );
    // --- End Path Calculation ---

    // --- Routing Setup ---
    // API routes (add more later in handlers.rs)
    let api_routes = Router::new()
        .route("/health", get(handlers::health_check_handler))
        .route("/save_animation", post(handlers::save_animation_handler))
        .route("/load_animation/:id", get(handlers::load_animation_handler));

    // Service to serve WASM package files from `../geco/pkg`
    let wasm_pkg_service = ServeDir::new(wasm_pkg_path).append_index_html_on_directories(false);

    // Service to serve static frontend files from `../frontend`
    let static_files_service = ServeDir::new(frontend_path).append_index_html_on_directories(true); // Serve index.html for directories like "/"

    let app = Router::new()
        .merge(SwaggerUi::new("/swagger-ui").url("/api-docs/openapi.json", ApiDoc::openapi()))
        .nest("/api", api_routes) // API routes under /api
        .nest_service("/pkg", wasm_pkg_service) // WASM files under /pkg
        .fallback_service(static_files_service) // Serve frontend static files as fallback
        //.layer(Extension(pool)) // Add database pool state
        .with_state(pool.clone())
        //.layer(Extension(pool))
        .layer(TraceLayer::new_for_http()) // Add HTTP request logging
        .layer(
            // Add CORS layer - Allow requests from any origin (adjust for production)
            CorsLayer::new()
                .allow_origin(Any)
                .allow_methods(Any) // Allows common methods
                .allow_headers(Any), // Allows common headers
        );
    // --- End Routing Setup ---

    // --- Server Startup ---
    let port_str = env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let port = port_str
        .parse::<u16>()
        .expect("PORT must be a valid u16 number");
    let addr = SocketAddr::from(([0, 0, 0, 0], port)); // Listen on all interfaces

    tracing::debug!("Server listening on http://{}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    // Use ServiceExt::<Request>::into_make_service()
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}
