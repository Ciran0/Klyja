// In geco/src/lib.rs

pub mod protobuf_gen {
    // This line includes the Rust code generated by prost_build from your .proto file.
    // The path comes from the OUT_DIR environment variable set during the build.
    include!(concat!(env!("OUT_DIR"), "/klyja.map_animation.v1.rs"));
}

// Ensure you import the new generated types
use crate::protobuf_gen::{
    Feature, FeatureStructureSnapshot, FeatureType, MapAnimation, Point, PointAnimationPath,
    PositionKeyframe,
};
use nalgebra::{Unit, Vector3}; // Make sure Unit is imported
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);
}

macro_rules! console_log {
    ($($t:tt)*) => {
        #[cfg(target_arch = "wasm32")]
        { log(&format_args!($($t)*).to_string()); }
        #[cfg(not(target_arch = "wasm32"))]
        { println!("GecoLog (native): {}", format_args!($($t)*).to_string()); }
    }
}

#[derive(Serialize, Deserialize)]
pub struct WasmVectorData {
    pub vertex_data: Vec<f32>, // A flat array of [x1, y1, z1, x2, y2, z2, ...]
    pub segment_count: u32,    // The number of line segments in the array
}

#[derive(Serialize, Deserialize)]
struct SimplePointJson {
    x: f32,
    y: f32,
    z: Option<f32>,
}

impl From<&Point> for SimplePointJson {
    fn from(p: &Point) -> Self {
        SimplePointJson {
            x: p.x,
            y: p.y,
            z: p.z,
        }
    }
}

#[derive(Serialize, Deserialize)]
struct RenderableFeatureJson {
    feature_id: String,
    name: String,
    feature_type: String,
    points: Vec<SimplePointJson>,
    properties: std::collections::HashMap<String, String>,
}

pub(crate) fn interpolate_point_position(
    path: &PointAnimationPath,
    current_frame: i32,
) -> Option<Point> {
    if path.keyframes.is_empty() {
        return None;
    }

    let keyframes = &path.keyframes;
    let mut prev_kf: Option<&PositionKeyframe> = None;
    let mut next_kf: Option<&PositionKeyframe> = None;

    for kf in keyframes {
        if kf.frame <= current_frame {
            prev_kf = Some(kf);
        }
        if kf.frame >= current_frame {
            next_kf = Some(kf);
            break;
        }
    }

    match (prev_kf, next_kf) {
        (Some(pkf), None) => pkf.position.clone(),
        (None, Some(nkf)) => nkf.position.clone(),
        (None, None) => None,
        (Some(pkf), Some(nkf)) => {
            if pkf.frame == nkf.frame {
                return pkf.position.clone();
            }
            if pkf.frame == current_frame {
                return pkf.position.clone();
            }
            if nkf.frame == current_frame {
                return nkf.position.clone();
            }

            let p0_proto = pkf.position.as_ref()?;
            let p1_proto = nkf.position.as_ref()?;

            let p0_vec = Vector3::new(p0_proto.x, p0_proto.y, p0_proto.z.unwrap_or(0.0f32));
            let p1_vec = Vector3::new(p1_proto.x, p1_proto.y, p1_proto.z.unwrap_or(0.0f32));

            let t_total = (nkf.frame - pkf.frame) as f32;
            let t_current = (current_frame - pkf.frame) as f32;

            if t_total == 0.0 {
                return pkf.position.clone();
            }
            let t = t_current / t_total;

            let p0_unit = Unit::new_normalize(p0_vec);
            let p1_unit = Unit::new_normalize(p1_vec);

            let dot = p0_unit.dot(&p1_unit);
            let interpolated_vec;

            if (dot - 1.0).abs() < 1e-5 {
                interpolated_vec = p0_unit.into_inner();
            } else if (dot + 1.0).abs() < 1e-5 {
                let mut temp_candidate_for_cross = Vector3::x_axis().into_inner();
                if p0_unit.cross(&temp_candidate_for_cross).magnitude_squared() < 1e-6 {
                    temp_candidate_for_cross = Vector3::y_axis().into_inner();
                    if p0_unit.cross(&temp_candidate_for_cross).magnitude_squared() < 1e-6 {
                        temp_candidate_for_cross = Vector3::z_axis().into_inner();
                    }
                }

                let rotation_axis_vec = p0_unit.cross(&temp_candidate_for_cross);

                if rotation_axis_vec.magnitude_squared() < 1e-5 {
                    let axis_for_rotation = if p0_unit.z.abs() > 0.99 {
                        Unit::new_normalize(Vector3::x_axis().into_inner())
                    } else if p0_unit.x.abs() > 0.99 {
                        Unit::new_normalize(Vector3::z_axis().into_inner())
                    } else {
                        Unit::new_normalize(rotation_axis_vec)
                    };
                    let rot = nalgebra::Rotation3::from_axis_angle(
                        &axis_for_rotation,
                        t * std::f32::consts::PI,
                    );
                    interpolated_vec = rot * p0_unit.into_inner();
                } else {
                    let rotation_axis_unit = Unit::new_normalize(rotation_axis_vec);
                    let rot = nalgebra::Rotation3::from_axis_angle(
                        &rotation_axis_unit,
                        t * std::f32::consts::PI,
                    );
                    interpolated_vec = rot * p0_unit.into_inner();
                }
            } else {
                interpolated_vec = p0_unit.slerp(&p1_unit, t).into_inner();
            }

            Some(Point {
                x: interpolated_vec.x,
                y: interpolated_vec.y,
                z: Some(interpolated_vec.z),
            })
        }
    }
}

#[wasm_bindgen]
pub struct Geco {
    animation_state: MapAnimation,
    active_feature_id: Option<String>,
}

#[wasm_bindgen]
impl Geco {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        console_log!("Geco::new() called - Feature Edition");
        Geco {
            animation_state: MapAnimation {
                animation_id: format!("anim-{}", Uuid::new_v4()),
                name: "Untitled Animation".to_string(),
                total_frames: 100,
                features: vec![],
            },
            active_feature_id: None,
        }
    }

    #[wasm_bindgen(js_name = getActiveFeatureId)]
    pub fn get_active_feature_id(&self) -> Option<String> {
        self.active_feature_id.clone()
    }

    pub fn set_total_frames(&mut self, total_frames: i32) {
        if total_frames > 0 {
            self.animation_state.total_frames = total_frames;
        }
    }

    pub fn get_total_frames(&self) -> i32 {
        self.animation_state.total_frames
    }

    pub fn get_animation_name(&self) -> String {
        self.animation_state.name.clone()
    }

    pub fn set_animation_name(&mut self, name: String) {
        self.animation_state.name = name;
    }

    pub fn get_animation_protobuf(&self) -> Vec<u8> {
        use prost::Message;
        self.animation_state.encode_to_vec()
    }

    pub fn load_animation_protobuf(&mut self, data: &[u8]) -> Result<(), JsValue> {
        use prost::Message;
        match MapAnimation::decode(data) {
            Ok(decoded_state) => {
                self.animation_state = decoded_state;
                self.active_feature_id = self
                    .animation_state
                    .features
                    .last()
                    .map(|f| f.feature_id.clone());
                console_log!(
                    "Protobuf (Feature Edition) deserialized. Name: {}. Active feature: {:?}",
                    self.animation_state.name,
                    self.active_feature_id
                );
                Ok(())
            }
            Err(e) => {
                let error_msg = format!("Failed to decode Protobuf: {}", e);
                console_log!("Error: {}", error_msg);
                Err(JsValue::from_str(&error_msg))
            }
        }
    }

    pub fn create_feature(
        &mut self,
        name: String,
        feature_type_val: u32,
        appearance_frame: i32,
        disappearance_frame: i32,
    ) -> Result<String, JsValue> {
        let feature_id = format!("feature-{}", Uuid::new_v4());
        let feature_type = match feature_type_val {
            1 => FeatureType::Polygon,
            2 => FeatureType::Polyline,
            _ => return Err(JsValue::from_str("Invalid feature type value")),
        };

        // Create an initial empty snapshot at the appearance frame
        let initial_snapshot = FeatureStructureSnapshot {
            frame: appearance_frame.max(0), // Ensure frame is not negative
            ordered_point_ids: vec![],      // Empty points initially
        };

        let new_feature = Feature {
            feature_id: feature_id.clone(),
            name,
            r#type: feature_type.into(),
            appearance_frame,
            disappearance_frame,
            point_animation_paths: vec![],
            structure_snapshots: vec![initial_snapshot], // Add the initial snapshot
            properties: Default::default(),
        };
        self.animation_state.features.push(new_feature);
        self.active_feature_id = Some(feature_id.clone());
        console_log!(
            "Created feature: {} (ID: {})",
            self.animation_state.features.last().unwrap().name,
            feature_id
        );
        Ok(feature_id)
    }

    pub fn add_point_to_active_feature(
        &mut self,
        point_id_str: String,
        initial_frame: i32,
        x: f32,
        y: f32,
        z: Option<f32>,
    ) -> Result<String, JsValue> {
        let active_id = self
            .active_feature_id
            .clone()
            .ok_or_else(|| JsValue::from_str("No active feature selected"))?;
        let feature = self
            .animation_state
            .features
            .iter_mut()
            .find(|f| f.feature_id == active_id)
            .ok_or_else(|| JsValue::from_str("Active feature not found"))?;

        let point_id = if point_id_str.is_empty() {
            format!("point-{}", Uuid::new_v4())
        } else {
            point_id_str
        };

        if feature
            .point_animation_paths
            .iter()
            .any(|pap| pap.point_id == point_id)
        {
            return Err(JsValue::from_str(&format!(
                "Point ID '{}' already exists in feature '{}'",
                point_id, active_id
            )));
        }

        let z_val = z.unwrap_or(0.0);
        let mut magnitude = (x * x + y * y + z_val * z_val).sqrt();
        if magnitude == 0.0 {
            console_log!("Warning: Attempted to add point at origin. Defaulting magnitude to 1");
            magnitude = 1.0; // Avoid division by zero, ensure point is on unit sphere surface
        }
        let norm_x = x / magnitude;
        let norm_y = y / magnitude;
        let norm_z = z_val / magnitude;

        let initial_keyframe = PositionKeyframe {
            frame: initial_frame,
            position: Some(Point {
                x: norm_x,
                y: norm_y,
                z: Some(norm_z),
            }),
        };
        let point_path = PointAnimationPath {
            point_id: point_id.clone(),
            keyframes: vec![initial_keyframe],
        };
        feature.point_animation_paths.push(point_path);

        // Use initial_frame for the snapshot where the point is added.
        // If a snapshot at this frame exists, add to it. Otherwise, create a new one.
        // Important: This needs to handle existing points in that snapshot.

        let mut snapshot_exists_at_frame = false;
        for snapshot in feature.structure_snapshots.iter_mut() {
            if snapshot.frame == initial_frame {
                // Add to existing snapshot if it doesn't already contain the point
                if !snapshot.ordered_point_ids.contains(&point_id) {
                    snapshot.ordered_point_ids.push(point_id.clone());
                }
                snapshot_exists_at_frame = true;
                break;
            }
        }

        if !snapshot_exists_at_frame {
            // Create a new snapshot. If there was a previous snapshot, inherit its points.
            let previous_points = feature
                .structure_snapshots
                .iter()
                .filter(|ss| ss.frame < initial_frame)
                .max_by_key(|ss| ss.frame)
                .map(|ss| ss.ordered_point_ids.clone())
                .unwrap_or_default();

            let mut new_ordered_points = previous_points;
            if !new_ordered_points.contains(&point_id) {
                new_ordered_points.push(point_id.clone());
            }

            feature.structure_snapshots.push(FeatureStructureSnapshot {
                frame: initial_frame,
                ordered_point_ids: new_ordered_points,
            });
        }

        // Ensure snapshots are sorted by frame after modification
        feature.structure_snapshots.sort_by_key(|ss| ss.frame);

        console_log!(
            "Added point '{}' to feature '{}' at frame {}",
            point_id,
            active_id,
            initial_frame
        );
        Ok(point_id)
    }

    pub fn add_position_keyframe_to_point(
        &mut self,
        feature_id: String,
        point_id: String,
        frame: i32,
        x: f32,
        y: f32,
        z: Option<f32>,
    ) -> Result<(), JsValue> {
        let feature = self
            .animation_state
            .features
            .iter_mut()
            .find(|f| f.feature_id == feature_id)
            .ok_or_else(|| JsValue::from_str("Feature not found"))?;
        let point_path = feature
            .point_animation_paths
            .iter_mut()
            .find(|pap| pap.point_id == point_id)
            .ok_or_else(|| JsValue::from_str("Point not found in feature"))?;

        let z_val = z.unwrap_or(0.0);
        let mut magnitude = (x * x + y * y + z_val * z_val).sqrt();
        if magnitude == 0.0 {
            console_log!(
                "Warning: Attempted to add keyframe at origin. Defaulting magnitude to 1."
            );
            magnitude = 1.0;
        }
        let norm_x = x / magnitude;
        let norm_y = y / magnitude;
        let norm_z = z_val / magnitude;

        let new_keyframe = PositionKeyframe {
            frame,
            position: Some(Point {
                x: norm_x,
                y: norm_y,
                z: Some(norm_z),
            }),
        };
        point_path.keyframes.push(new_keyframe);
        point_path.keyframes.sort_by_key(|kf| kf.frame); // Keep keyframes sorted
        console_log!(
            "Added keyframe to point '{}' in feature '{}' at frame {}",
            point_id,
            feature_id,
            frame
        );
        Ok(())
    }

    fn get_renderable_state_internal(&self, frame_number: i32) -> Vec<RenderableFeatureJson> {
        let mut renderable_features = Vec::new();
        for feature_proto in &self.animation_state.features {
            if frame_number < feature_proto.appearance_frame
                || frame_number > feature_proto.disappearance_frame
            {
                continue;
            }
            let current_structure_snapshot = feature_proto
                .structure_snapshots
                .iter()
                .filter(|ss| ss.frame <= frame_number)
                .max_by_key(|ss| ss.frame);

            if let Some(snapshot) = current_structure_snapshot {
                let mut current_points_for_feature = Vec::new();
                for point_id_in_snapshot in &snapshot.ordered_point_ids {
                    if let Some(point_path) = feature_proto
                        .point_animation_paths
                        .iter()
                        .find(|pap| pap.point_id == *point_id_in_snapshot)
                    {
                        if let Some(interpolated_pos) =
                            interpolate_point_position(point_path, frame_number)
                        {
                            current_points_for_feature
                                .push(SimplePointJson::from(&interpolated_pos));
                        }
                    }
                }
                // Add feature if it has points OR if its defining snapshot is empty (meaning it's an empty feature)
                if !current_points_for_feature.is_empty() || snapshot.ordered_point_ids.is_empty() {
                    renderable_features.push(RenderableFeatureJson {
                        feature_id: feature_proto.feature_id.clone(),
                        name: feature_proto.name.clone(),
                        feature_type: format!(
                            "{:?}",
                            FeatureType::try_from(feature_proto.r#type).unwrap_or_default()
                        ),
                        points: current_points_for_feature,
                        properties: feature_proto.properties.clone(),
                    });
                }
            }
        }
        renderable_features
    }

    pub fn get_renderable_features_json_at_frame(&self, frame_number: i32) -> String {
        console_log!(
            "Geco: get_renderable_features_json_at_frame for frame {}",
            frame_number
        );
        let renderable_state = self.get_renderable_state_internal(frame_number);
        match serde_json::to_string(&renderable_state) {
            Ok(json) => json,
            Err(e) => {
                console_log!("Error serializing renderable state to JSON: {}", e);
                "[]".to_string() // Return empty array string on error
            }
        }
    }

    #[wasm_bindgen(js_name = getRenderableLineSegmentsAtFrame)]
    pub fn get_renderable_line_segments_at_frame(
        &self,
        frame_number: i32,
    ) -> Result<JsValue, JsValue> {
        let mut vertex_data = Vec::<f32>::new();
        let mut segment_count: u32 = 0;

        console_log!("--- New Frame {} ---", frame_number);

        for feature in &self.animation_state.features {
            // Skip features that are not visible at the current frame
            if frame_number < feature.appearance_frame || frame_number > feature.disappearance_frame
            {
                continue;
            }

            // Find the most recent structural snapshot for the current frame
            let current_snapshot = feature
                .structure_snapshots
                .iter()
                .filter(|ss| ss.frame <= frame_number)
                .max_by_key(|ss| ss.frame);

            if let Some(snapshot) = current_snapshot {
                if snapshot.ordered_point_ids.len() < 2 {
                    continue; // Not enough points to form a line
                }

                // Interpolate all points for the current frame and collect them.
                // Using a HashMap is efficient for looking up points by their ID.
                let point_paths_map: std::collections::HashMap<_, _> = feature
                    .point_animation_paths
                    .iter()
                    .map(|p| (p.point_id.clone(), p))
                    .collect();

                let interpolated_points: Vec<Point> = snapshot
                    .ordered_point_ids
                    .iter()
                    .filter_map(|id| point_paths_map.get(id))
                    .filter_map(|path| interpolate_point_position(path, frame_number))
                    .collect();

                if interpolated_points.len() < 2 {
                    continue;
                }

                // Create line segments from the interpolated points.
                // The `.windows(2)` iterator gives us overlapping pairs of points [P1, P2], then [P2, P3], etc.
                for segment_points in interpolated_points.windows(2) {
                    let p1 = &segment_points[0];
                    let p2 = &segment_points[1];

                    console_log!(
                        "Adding segment: P1({:.2}, {:.2}, {:.2}) -> P2({:.2}, {:.2}, {:.2})",
                        p1.x,
                        p1.y,
                        p1.z.unwrap_or(0.0),
                        p2.x,
                        p2.y,
                        p2.z.unwrap_or(0.0)
                    );

                    vertex_data.extend_from_slice(&[
                        p1.x,
                        p1.y,
                        p1.z.unwrap_or(0.0),
                        p2.x,
                        p2.y,
                        p2.z.unwrap_or(0.0),
                    ]);
                    segment_count += 1;
                }

                // If the feature is a closed polygon, add the closing segment
                let feature_type = FeatureType::try_from(feature.r#type).unwrap_or_default();
                console_log!("- checking feature type: {:?}", feature_type);
                if feature_type == FeatureType::Polygon {
                    if let (Some(first_point), Some(last_point)) =
                        (interpolated_points.first(), interpolated_points.last())
                    {
                        console_log!("Closing polygon...");
                        vertex_data.extend_from_slice(&[
                            last_point.x,
                            last_point.y,
                            last_point.z.unwrap_or(0.0),
                            first_point.x,
                            first_point.y,
                            first_point.z.unwrap_or(0.0),
                        ]);
                        segment_count += 1;
                    }
                }
            }
        }

        let vector_data = WasmVectorData {
            vertex_data,
            segment_count,
        };

        // Serialize the result into a JsValue (JavaScript object)
        serde_wasm_bindgen::to_value(&vector_data).map_err(|e| e.into())
    }
}

// This line is needed for the tests module to be recognized
#[cfg(test)]
#[path = "lib_test.rs"]
mod tests;
