// In geco/src/lib.rs

pub mod protobuf_gen {
    // This line includes the Rust code generated by prost_build from your .proto file.
    // The path comes from the OUT_DIR environment variable set during the build.
    include!(concat!(env!("OUT_DIR"), "/klyja.map_animation.v1.rs"));
}

// Ensure you import the new generated types
// The exact path might vary slightly based on your `include!` and module structure
use crate::protobuf_gen::{
    Feature, FeatureStructureSnapshot, FeatureType, MapAnimation, Point, PointAnimationPath,
    PositionKeyframe,
};
use serde::Serialize; // For JSON serialization
use uuid::Uuid;
use wasm_bindgen::prelude::*; // For generating IDs

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str); // This is the JS import
}

// Modify the console_log! macro
macro_rules! console_log {
    ($($t:tt)*) => {
        #[cfg(target_arch = "wasm32")]
        {
            // When compiled for WASM, call the imported JavaScript `log` function.
            log(&format_args!($($t)*).to_string());
        }
        #[cfg(not(target_arch = "wasm32"))]
        {
            // When compiled for native (e.g., during `cargo test --lib`),
            // you can choose to do nothing, or print to the Rust console.
            // Option 1: Do nothing (console_log! will be a no-op in native tests)
            // {}

            // Option 2: Print to stdout for native tests
            println!("GecoLog (native): {}", format_args!($($t)*).to_string());
        }
    }
}

// Define simplified structs for JSON serialization (similar to your old ones)
#[derive(Serialize)]
struct SimplePointJson {
    x: f32,
    y: f32,
    z: Option<f32>,
}

impl From<&Point> for SimplePointJson {
    fn from(p: &Point) -> Self {
        SimplePointJson {
            x: p.x,
            y: p.y,
            z: p.z,
        }
    }
}

// Represents a feature with its current points for rendering
#[derive(Serialize)]
struct RenderableFeatureJson {
    feature_id: String,
    name: String,
    feature_type: String,         // "POLYGON" or "POLYLINE"
    points: Vec<SimplePointJson>, // Current interpolated positions of points
    properties: std::collections::HashMap<String, String>,
}

// Internal helper function (not wasm_bindgen exposed directly, or could be in a sub-module)
pub(crate) fn interpolate_point_position(
    path: &PointAnimationPath,
    current_frame: i32,
) -> Option<Point> {
    if path.keyframes.is_empty() {
        return None;
    }

    // Sort keyframes by frame just to be safe, though they should be sorted on add
    // For performance, ensure they are always sorted and remove this sort.
    // let mut sorted_keyframes = path.keyframes.clone();
    // sorted_keyframes.sort_by_key(|kf| kf.frame);
    // let keyframes = &sorted_keyframes; // if cloning/sorting here
    let keyframes = &path.keyframes;

    // Find the two keyframes that bracket the current_frame
    let mut prev_kf: Option<&PositionKeyframe> = None;
    let mut next_kf: Option<&PositionKeyframe> = None;

    for kf in keyframes {
        if kf.frame <= current_frame {
            prev_kf = Some(kf);
        }
        if kf.frame >= current_frame {
            next_kf = Some(kf);
            break; // Found the next or exact keyframe
        }
    }

    match (prev_kf, next_kf) {
        (Some(pkf), None) => pkf.position.clone(), // Past last keyframe, use last keyframe's position
        (None, Some(nkf)) => nkf.position.clone(), // Before first keyframe, use first keyframe's position
        (None, None) => None,                      // Should not happen if keyframes is not empty
        (Some(pkf), Some(nkf)) => {
            if pkf.frame == nkf.frame {
                // Exact match or only one keyframe
                return pkf.position.clone();
            }
            if pkf.frame == current_frame {
                // Exact match on previous keyframe
                return pkf.position.clone();
            }
            if nkf.frame == current_frame {
                // Exact match on next keyframe
                return nkf.position.clone();
            }

            let p1 = pkf.position.as_ref()?;
            let p2 = nkf.position.as_ref()?;

            let t_total = (nkf.frame - pkf.frame) as f32;
            let t_current = (current_frame - pkf.frame) as f32;

            if t_total == 0.0 {
                // Avoid division by zero if somehow frames are same but points differ
                return Some(p1.clone());
            }
            let factor = t_current / t_total;

            let x = p1.x + (p2.x - p1.x) * factor;
            let y = p1.y + (p2.y - p1.y) * factor;

            let z = match (p1.z, p2.z) {
                (Some(z1), Some(z2)) => Some(z1 + (z2 - z1) * factor),
                (Some(z1), None) => Some(z1), // Or handle as error, or interpolate to 0?
                (None, Some(z2)) => Some(z2), // Or handle as error, or interpolate from 0?
                (None, None) => None,
            };
            Some(Point { x, y, z })
        }
    }
}

#[wasm_bindgen]
pub struct Geco {
    animation_state: MapAnimation,
    active_feature_id: Option<String>, // To know which feature to add points/keyframes to
                                       // active_point_id: Option<String>, // Optional: if you want to select a point for keyframing
}

#[wasm_bindgen]
impl Geco {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        console_log!("Geco::new() called - Feature Edition");
        Geco {
            animation_state: MapAnimation {
                animation_id: format!("anim-{}", Uuid::new_v4()),
                name: "Untitled Animation".to_string(),
                total_frames: 100, // Default total frames, can be changed
                features: vec![],
            },
            active_feature_id: None,
        }
    }

    // Method to set total frames for the animation
    pub fn set_total_frames(&mut self, total_frames: i32) {
        if total_frames > 0 {
            self.animation_state.total_frames = total_frames;
        }
    }

    pub fn get_total_frames(&self) -> i32 {
        self.animation_state.total_frames
    }

    // Existing methods like get_animation_name, set_animation_name can be kept/adapted
    pub fn get_animation_name(&self) -> String {
        self.animation_state.name.clone()
    }

    pub fn set_animation_name(&mut self, name: String) {
        self.animation_state.name = name;
    }

    // Protobuf serialization/deserialization (should mostly work with new structs via prost)
    pub fn get_animation_protobuf(&self) -> Vec<u8> {
        use prost::Message; // Ensure prost::Message is in scope
        self.animation_state.encode_to_vec()
    }

    pub fn load_animation_protobuf(&mut self, data: &[u8]) -> Result<(), JsValue> {
        use prost::Message; // Ensure prost::Message is in scope
        match MapAnimation::decode(data) {
            Ok(decoded_state) => {
                self.animation_state = decoded_state;
                self.active_feature_id = self
                    .animation_state
                    .features
                    .last()
                    .map(|f| f.feature_id.clone());
                console_log!(
                    "Protobuf (Feature Edition) deserialized. Name: {}. Active feature: {:?}",
                    self.animation_state.name,
                    self.active_feature_id
                );
                Ok(())
            }
            Err(e) => {
                let error_msg = format!("Failed to decode Protobuf: {}", e);
                console_log!("Error: {}", error_msg);
                Err(JsValue::from_str(&error_msg))
            }
        }
    }

    pub fn create_feature(
        &mut self,
        name: String,
        feature_type_val: u32, // 0 for Polyline, 1 for Polygon (match JS expectations)
        appearance_frame: i32,
        disappearance_frame: i32,
    ) -> Result<String, JsValue> {
        let feature_id = format!("feature-{}", Uuid::new_v4());
        let feature_type = match feature_type_val {
            1 => FeatureType::Polygon,
            2 => FeatureType::Polyline,
            _ => return Err(JsValue::from_str("Invalid feature type value")),
        };

        let new_feature = Feature {
            feature_id: feature_id.clone(),
            name,
            r#type: feature_type.into(), // prost might generate `r#type`
            appearance_frame,
            disappearance_frame,
            point_animation_paths: vec![],
            structure_snapshots: vec![], // For Iteration 1, we might add one default snapshot here
            properties: Default::default(),
        };
        self.animation_state.features.push(new_feature);
        self.active_feature_id = Some(feature_id.clone());
        console_log!(
            "Created feature: {} (ID: {})",
            self.animation_state.features.last().unwrap().name,
            feature_id
        );
        Ok(feature_id)
    }

    // Adds a point to the currently active feature and sets its initial keyframe.
    // For Iteration 1, this point is also added to a single, initial structure snapshot.
    pub fn add_point_to_active_feature(
        &mut self,
        point_id_str: String, // Allow JS to suggest an ID, or generate if empty
        initial_frame: i32,
        x: f32,
        y: f32,
        z: Option<f32>,
    ) -> Result<String, JsValue> {
        let active_id = self
            .active_feature_id
            .clone()
            .ok_or_else(|| JsValue::from_str("No active feature selected"))?;

        let feature = self
            .animation_state
            .features
            .iter_mut()
            .find(|f| f.feature_id == active_id)
            .ok_or_else(|| JsValue::from_str("Active feature not found"))?;

        let point_id = if point_id_str.is_empty() {
            format!("point-{}", Uuid::new_v4())
        } else {
            point_id_str
        };

        // Check if point_id already exists in this feature
        if feature
            .point_animation_paths
            .iter()
            .any(|pap| pap.point_id == point_id)
        {
            return Err(JsValue::from_str(&format!(
                "Point ID '{}' already exists in feature '{}'",
                point_id, active_id
            )));
        }

        let initial_keyframe = PositionKeyframe {
            frame: initial_frame,
            position: Some(Point { x, y, z }),
        };

        let point_path = PointAnimationPath {
            point_id: point_id.clone(),
            keyframes: vec![initial_keyframe],
        };
        feature.point_animation_paths.push(point_path);

        // For Iteration 1: Assume a single structure snapshot at the feature's appearance frame,
        // or create/update one.
        // This part will become more complex when handling multiple snapshots.
        let snapshot_frame = feature.appearance_frame.max(0); // Or some other logic
        if let Some(snapshot) = feature
            .structure_snapshots
            .iter_mut()
            .find(|ss| ss.frame == snapshot_frame)
        {
            snapshot.ordered_point_ids.push(point_id.clone());
        } else {
            feature.structure_snapshots.push(FeatureStructureSnapshot {
                frame: snapshot_frame,
                ordered_point_ids: vec![point_id.clone()],
            });
        }
        // Sort snapshots by frame just in case
        feature.structure_snapshots.sort_by_key(|ss| ss.frame);

        console_log!(
            "Added point '{}' to feature '{}' at frame {}",
            point_id,
            active_id,
            initial_frame
        );
        Ok(point_id)
    }

    pub fn add_position_keyframe_to_point(
        &mut self,
        feature_id: String,
        point_id: String,
        frame: i32,
        x: f32,
        y: f32,
        z: Option<f32>,
    ) -> Result<(), JsValue> {
        let feature = self
            .animation_state
            .features
            .iter_mut()
            .find(|f| f.feature_id == feature_id)
            .ok_or_else(|| JsValue::from_str("Feature not found"))?;

        let point_path = feature
            .point_animation_paths
            .iter_mut()
            .find(|pap| pap.point_id == point_id)
            .ok_or_else(|| JsValue::from_str("Point not found in feature"))?;

        let new_keyframe = PositionKeyframe {
            frame,
            position: Some(Point { x, y, z }),
        };
        point_path.keyframes.push(new_keyframe);
        // Keep keyframes sorted by frame number for easier interpolation
        point_path.keyframes.sort_by_key(|kf| kf.frame);

        console_log!(
            "Added keyframe to point '{}' in feature '{}' at frame {}",
            point_id,
            feature_id,
            frame
        );
        Ok(())
    }

    // This is the core logic for getting the state at a frame for rendering
    // For Iteration 1, it assumes a fixed structure for each feature.
    fn get_renderable_state_internal(&self, frame_number: i32) -> Vec<RenderableFeatureJson> {
        let mut renderable_features = Vec::new();

        for feature in &self.animation_state.features {
            // Check if feature is active at this frame
            if frame_number < feature.appearance_frame || frame_number > feature.disappearance_frame
            {
                continue;
            }

            // For Iteration 1: Find the LATEST structure snapshot at or before current_frame.
            // If no snapshots, or all are in future, feature might not be fully defined yet.
            let current_structure_snapshot = feature
                .structure_snapshots
                .iter()
                .filter(|ss| ss.frame <= frame_number)
                .max_by_key(|ss| ss.frame);

            if let Some(snapshot) = current_structure_snapshot {
                let mut current_points_for_feature = Vec::new();
                for point_id in &snapshot.ordered_point_ids {
                    if let Some(point_path) = feature
                        .point_animation_paths
                        .iter()
                        .find(|pap| pap.point_id == *point_id)
                    {
                        if let Some(interpolated_pos) =
                            interpolate_point_position(point_path, frame_number)
                        {
                            current_points_for_feature
                                .push(SimplePointJson::from(&interpolated_pos));
                        }
                        // Else: point path found, but couldn't interpolate (e.g. no keyframes, or frame out of range)
                        // Decide how to handle - skip point, use default, etc.
                    }
                    // Else: point_id in snapshot not found in point_animation_paths - data inconsistency?
                }

                if !current_points_for_feature.is_empty() || snapshot.ordered_point_ids.is_empty() {
                    // Render even if no points, if it's an active feature
                    renderable_features.push(RenderableFeatureJson {
                        feature_id: feature.feature_id.clone(),
                        name: feature.name.clone(),
                        feature_type: format!(
                            "{:?}",
                            FeatureType::try_from(feature.r#type).unwrap_or_default()
                        ),
                        points: current_points_for_feature,
                        properties: feature.properties.clone(),
                    });
                }
            }
        }
        renderable_features
    }

    pub fn get_renderable_features_json_at_frame(&self, frame_number: i32) -> String {
        console_log!(
            "Geco: get_renderable_features_json_at_frame for frame {}",
            frame_number
        );
        let renderable_state = self.get_renderable_state_internal(frame_number);
        match serde_json::to_string(&renderable_state) {
            Ok(json) => json,
            Err(e) => {
                console_log!("Error serializing renderable state to JSON: {}", e);
                "[]".to_string() // Return empty JSON array on error
            }
        }
    }
}

#[cfg(test)]
#[path = "lib_test.rs"]
mod tests;
